import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart' hide Transaction;
import 'package:new_revenue/models/transaction.dart';
import 'package:new_revenue/models/budget.dart';
import 'dart:convert';

// Global variables provided by the Canvas environment.
const String __app_id =
    String.fromEnvironment('APP_ID', defaultValue: 'default-app-id');
const String __firebase_config =
    String.fromEnvironment('FIREBASE_CONFIG', defaultValue: '{}');
const String? __initial_auth_token =
    String.fromEnvironment('INITIAL_AUTH_TOKEN');

class FirestoreService {
  // --- Singleton setup ---
  static final FirestoreService _instance = FirestoreService._internal();
  factory FirestoreService() => _instance;
  FirestoreService._internal(); // Private constructor

  late FirebaseApp _app;
  late FirebaseAuth _auth;
  late FirebaseFirestore _db;
  String? _userId; // To store the current user's ID
  bool _isFirebaseInitialized = false; // Flag to track Firebase initialization

  // Getters for Firebase instances
  FirebaseApp get app => _app;
  FirebaseAuth get auth => _auth;
  FirebaseFirestore get db => _db;
  String? get userId => _userId;

  // Access global variables directly
  final String _appId = __app_id;
  final Map<String, dynamic> _firebaseConfig = jsonDecode(__firebase_config);
  final String? _initialAuthToken = __initial_auth_token;

  Future<void> initializeFirebase() async {
    if (_isFirebaseInitialized) {
      print('FirebaseService already initialized.');
      return; // Prevent re-initialization
    }

    if (Firebase.apps.isEmpty) {
      _app = await Firebase.initializeApp(
        options: FirebaseOptions(
          apiKey: _firebaseConfig['apiKey'] ?? '',
          appId: _firebaseConfig['appId'] ?? '',
          messagingSenderId: _firebaseConfig['messagingSenderId'] ?? '',
          projectId: _firebaseConfig['projectId'] ?? '',
          storageBucket: _firebaseConfig['storageBucket'] ?? '',
        ),
      );
    } else {
      _app = Firebase.app();
    }

    _auth = FirebaseAuth.instanceFor(app: _app);
    _db = FirebaseFirestore.instanceFor(app: _app);
    _isFirebaseInitialized = true; // Set flag after successful initialization

    // Only attempt custom token sign-in if a token is provided.
    if (_initialAuthToken != null && _initialAuthToken!.isNotEmpty) {
      try {
        await _auth.signInWithCustomToken(_initialAuthToken!);
        _userId = _auth.currentUser?.uid;
        print('Signed in with custom token. User ID: $_userId');
      } catch (e) {
        print('Error signing in with custom token: $e');
        // If custom token fails, _userId will remain null,
        // and AuthWrapper will correctly show AuthScreen.
      }
    }

    // Listen for auth state changes to keep _userId updated
    _auth.authStateChanges().listen((user) {
      _userId = user?.uid;
    });
  }

  // Get the collection path for user-specific transactions
  String _getTransactionsCollectionPath() {
    if (_userId == null || _userId!.isEmpty) {
      print(
          'Warning: userId is null or empty. Using a default path for transactions.');
      return 'artifacts/$_appId/users/default_user/transactions';
    }
    return 'artifacts/$_appId/users/$_userId/transactions';
  }

  // Get the collection path for user-specific budgets
  String _getBudgetsCollectionPath() {
    if (_userId == null || _userId!.isEmpty) {
      print(
          'Warning: userId is null or empty. Using a default path for budgets.');
      return 'artifacts/$_appId/users/default_user/budgets';
    }
    return 'artifacts/$_appId/users/$_userId/budgets';
  }

  // Add a new transaction to Firestore
  Future<void> addTransaction({
    required String title,
    required double amount,
    required String type,
    required String category,
    required DateTime date,
  }) async {
    if (_userId == null) {
      throw Exception('User not authenticated. Cannot add transaction.');
    }

    final transaction = Transaction(
      id: '', // ID will be generated by Firestore
      title: title,
      amount: amount,
      type: type,
      category: category,
      date: date,
      userId: _userId!,
    );

    try {
      await _db
          .collection(_getTransactionsCollectionPath())
          .add(transaction.toMap());
      print('Transaction added successfully!');
    } catch (e) {
      print('Error adding transaction: $e');
      rethrow;
    }
  }

  // Get a stream of transactions for the current user
  Stream<List<Transaction>> getTransactionsStream() {
    if (_userId == null) {
      return Stream.value([]);
    }
    return _db
        .collection(_getTransactionsCollectionPath())
        .snapshots()
        .map((snapshot) {
      return snapshot.docs
          .map((doc) => Transaction.fromFirestore(doc))
          .toList();
    });
  }

  // Optional: Delete a transaction
  Future<void> deleteTransaction(String transactionId) async {
    if (_userId == null) {
      throw Exception('User not authenticated. Cannot delete transaction.');
    }
    try {
      await _db
          .collection(_getTransactionsCollectionPath())
          .doc(transactionId)
          .delete();
      print('Transaction deleted successfully!');
    } catch (e) {
      print('Error deleting transaction: $e');
      rethrow;
    }
  }

  // --- Budget related methods ---

  // Add a new budget to Firestore
  Future<void> addBudget(Budget budget) async {
    if (_userId == null) {
      throw Exception('User not authenticated. Cannot add budget.');
    }
    try {
      await _db.collection(_getBudgetsCollectionPath()).add(budget.toMap());
      print('Budget added successfully!');
    } catch (e) {
      print('Error adding budget: $e');
      rethrow;
    }
  }

  // Update an existing budget in Firestore
  Future<void> updateBudget(Budget budget) async {
    if (_userId == null) {
      throw Exception('User not authenticated. Cannot update budget.');
    }
    if (budget.id.isEmpty) {
      throw Exception('Budget ID is required for updating.');
    }
    try {
      await _db
          .collection(_getBudgetsCollectionPath())
          .doc(budget.id)
          .update(budget.toMap());
      print('Budget updated successfully!');
    } catch (e) {
      print('Error updating budget: $e');
      rethrow;
    }
  }

  // Delete a budget from Firestore
  Future<void> deleteBudget(String budgetId) async {
    if (_userId == null) {
      throw Exception('User not authenticated. Cannot delete budget.');
    }
    try {
      await _db.collection(_getBudgetsCollectionPath()).doc(budgetId).delete();
      print('Budget deleted successfully!');
    } catch (e) {
      print('Error deleting budget: $e');
      rethrow;
    }
  }

  // Get a stream of budgets for the current user
  Stream<List<Budget>> getBudgetsStream() {
    if (_userId == null) {
      return Stream.value([]);
    }
    return _db
        .collection(_getBudgetsCollectionPath())
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => Budget.fromFirestore(doc)).toList();
    });
  }
}
